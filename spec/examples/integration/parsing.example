require "spec_helper"

describe "Parsing" do
  include NavigationMatchers

  context "X222-HC837" do
    let(:parser) { Fixtures.file("X222-HC837/1-good.txt") }

    it "parses 1-good.txt" do
      parser.should be_deterministic
      parser.should be_last

      parser.segment.tap do |iea|
        iea.node.position.line.should   == 53
        iea.node.position.column.should == 1
      end

      parser.should have_sequence(%w(ISA GS ST BHT NM1 PER NM1 HL PRV NM1 N3 N4
        REF NM1 N3 N4 HL SBR NM1 N3 N4 DMG NM1 N4 REF HL PAT NM1 N3 N4 DMG CLM
        REF HI LX SV1 DTP LX SV1 DTP LX SV1 DTP LX SV1 DTP SE GE IEA))

      parser.should have_separators(:element => "*", :component => ":",
                                    :repetition => "^", :segment => "~")

      parser.parent.tap do |isa|
        # Should have 49 total segments in the parse tree
        isa.should have_distance(48).to(parser)

        # See matchers/navigation_matchers.rb
        #
        # Ss: list of segment matchers
        #  C: composite element
        #
        #  S: the segment might be reachable, and /is/ reachable
        #  R: the segment might be reachable, but didn't occur
        #  X: the segment would never be reachable
        #
        isa.should have_structure(
          Ss(X(:ST),
             R(:ISA), # No more ISAs
             S(:GS, "HC", nil, nil, nil, nil, 1) =>
               Ss(R(:GS), # No more GSs
                  S(:ST) =>
                    Ss(R(:ST), # No more STs
                       X(:PRV),
                       X(:NM1, "85"),
                       X(:NM1, "87"),
                       X(:SBR),
                       X(:NM1, "IL"),
                       X(:NM1, "PR"),
                       S(:BHT) =>
                         Ss(S(:NM1, "41"),
                            S(:NM1, "40"),
                            S(:HL, "1"),
                            S(:HL, "2"),
                            S(:HL, "3"),
                            S(:SE),
                            S(:GE),
                            S(:IEA)),
                       # 1000A SUBMITTER NAME
                       S(:NM1, "41") =>
                         Ss(S(:PER),
                            S(:NM1, "40"),
                            S(:HL,  "1"),
                            S(:HL,  "2"),
                            S(:HL,  "3"),
                            S(:SE),
                            S(:GE),
                            S(:IEA)),
                       # 1000B RECEIVER NAME
                       S(:NM1, "40") =>
                         Ss(S(:HL, "1"),
                            S(:HL, "2"),
                            S(:HL, "3"),
                            S(:SE),
                            S(:GE),
                            S(:IEA)),
                       # 2000A BILLING PROVIDER HIERARCHICAL LEVEL
                       S(:HL, "1") =>
                         Ss(S(:PRV) =>
                              Ss(S(:NM1, "85"),
                                 S(:NM1, "87"),
                                 S(:HL, "2"),
                                 S(:HL, "3"),
                                 S(:SE),
                                 S(:GE),
                                 S(:IEA)),
                            # 2010AA BILLING PROVIDER NAME
                            S(:NM1, "85") =>
                              Ss(S(:NM1, "87") => Ss(),
                                 S(:N3)        => Ss(S(:N4),
                                                     S(:REF, "EI"),
                                                     S(:NM1, "87")),
                                 S(:N4)        => Ss(S(:REF, "EI"),
                                                     S(:NM1, "87")),
                                 S(:REF, "EI") => Ss(S(:NM1, "87")),
                                 S(:SE)        => Ss(),
                                 S(:GE)        => Ss(),
                                 S(:IEA)       => Ss()),
                            # 2010AB PAY-TO ADDRESS NAME
                            S(:NM1, "87") =>
                              Ss(S(:N3)  => Ss(S(:N4),
                                               S(:HL, "2")),
                                 S(:N4)  => Ss(S(:HL, "2")),
                                 S(:SE)  => Ss(),
                                 S(:GE)  => Ss(),
                                 S(:IEA) => Ss()),
                            S(:HL, "2") => Ss(),
                            S(:HL, "3") => Ss(),
                            S(:SE)      => Ss(),
                            S(:GE)      => Ss(),
                            S(:IEA)     => Ss()),
                         # 2000B SUBSCRIBER HIERARCHICAL LEVEL
                         S(:HL, "2") =>
                           Ss(S(:SBR) =>
                                Ss(S(:NM1, "IL"),
                                   S(:NM1, "PR"),
                                   S(:HL, "3"),
                                   S(:SE),
                                   S(:GE),
                                   S(:IEA)),
                              # 2010BA SUBSCRIBER NAME
                              S(:NM1, "IL") =>
                                Ss(S(:N3)  => Ss(S(:N4),
                                                 S(:DMG),
                                                 S(:NM1, "PR"),
                                                 S(:HL, "3")),
                                   S(:N4)  => Ss(S(:DMG),
                                                 S(:NM1, "PR"),
                                                 S(:HL, "3")),
                                   S(:DMG) => Ss(S(:NM1, "PR"),
                                                 S(:HL, "3")),
                                   S(:SE)  => Ss(),
                                   S(:GE)  => Ss(),
                                   S(:IEA) => Ss()),
                              # 2010BB PAYER NAME
                              S(:NM1, "PR") =>
                                Ss(S(:N4) => Ss(S(:REF, "G2"),
                                                S(:HL, "3")),
                                   S(:REF, "G2") => Ss(S(:HL, "3")),
                                   S(:SE)        => Ss(),
                                   S(:GE)        => Ss(),
                                   S(:IEA)       => Ss()),
                              S(:HL, "3") => Ss(),
                              S(:SE)      => Ss(),
                              S(:GE)      => Ss(),
                              S(:IEA)     => Ss()),
                         # 2000C PATIENT HIERARCHICAL LEVEL
                         S(:HL, "3") =>
                           Ss(S(:PAT) => Ss(S(:NM1, "QC"),
                                            S(:CLM),
                                            S(:SE),
                                            S(:GE),
                                            S(:IEA)),
                              # 2010CA PATIENT NAME
                              S(:NM1, "QC") =>
                                Ss(S(:N3)  => Ss(S(:N4),
                                                 S(:DMG),
                                                 S(:CLM)),
                                   S(:N4)  => Ss(S(:DMG),
                                                 S(:CLM)),
                                   S(:DMG) => Ss(S(:CLM)),
                                   S(:CLM) => Ss(),
                                   S(:SE)  => Ss(),
                                   S(:GE)  => Ss(),
                                   S(:IEA) => Ss()),
                              # 2300 CLAIM INFORMATION
                              S(:CLM) =>
                                Ss(R(:CLM), # No more CLMs
                                   S(:REF, "D9"),
                                   S(:HI, C("BK", "0340"), C("BF", "V7389")),
                                   # 2400 SERVICE LINE NUMBER
                                   S(:LX, "1") =>
                                     Ss(R(:LX, "1"), # No more LX*1's
                                        S(:LX, "2"),
                                        S(:LX, "3"),
                                        S(:LX, "4"),
                                        S(:SV1, C(nil, "99213")) => Ss(S(:DTP, "472"),
                                                                       S(:LX, "2"),
                                                                       S(:LX, "3"),
                                                                       S(:LX, "4"),
                                                                       S(:SE),
                                                                       S(:GE),
                                                                       S(:IEA)),
                                        S(:DTP, "472") => Ss(S(:LX, "2"),
                                                             S(:LX, "3"),
                                                             S(:LX, "4"),
                                                             S(:SE),
                                                             S(:GE),
                                                             S(:IEA))),
                                   # 2400 SERVICE LINE NUMBER
                                   S(:LX, "2") =>
                                     Ss(R(:LX, "1"),
                                        R(:LX, "2"), # No more LX*2's
                                        S(:LX, "3"),
                                        S(:LX, "4"),
                                        S(:SV1, C(nil, "87070")) => Ss(S(:DTP, "472"),
                                                                       S(:LX, "3"),
                                                                       S(:LX, "4"),
                                                                       S(:SE),
                                                                       S(:GE),
                                                                       S(:IEA)),
                                        S(:DTP, "472") => Ss(S(:LX, "3"),
                                                             S(:LX, "4"),
                                                             S(:SE),
                                                             S(:GE),
                                                             S(:IEA))),
                                   # 2400 SERVICE LINE NUMBER
                                   S(:LX, "3") =>
                                     Ss(R(:LX, "1"), # No more LX*1's
                                        R(:LX, "2"), # No more LX*2's
                                        R(:LX, "3"), # No more LX*3's
                                        S(:LX, "4"),
                                        S(:SV1, C(nil, "99214")) => Ss(S(:DTP, "472"),
                                                                       S(:LX, "4"),
                                                                       S(:SE),
                                                                       S(:GE),
                                                                       S(:IEA)),
                                        S(:DTP, "472") => Ss(S(:LX, "4"),
                                                             S(:SE),
                                                             S(:GE),
                                                             S(:IEA))),
                                   # 2400 SERVICE LINE NUMBER
                                   S(:LX, "4") =>
                                     Ss(R(:LX, "1"),
                                        R(:LX, "2"),
                                        R(:LX, "3"),
                                        R(:LX, "4"),
                                        S(:SV1, C(nil, "86663")) => Ss(S(:DTP, "472"),
                                                                       S(:SE),
                                                                       S(:GE),
                                                                       S(:IEA)),
                                        S(:DTP, "472") => Ss(S(:SE),
                                                             S(:GE),
                                                             S(:IEA))))),
                       S(:SE) => Ss(S(:GE),
                                    S(:IEA))),
                  S(:GE)  => Ss(S(:IEA)),
                  S(:IEA) => Ss())))
      end
    end
  end

  context "X221-HP835" do

    it "parses 1-good.txt" do
      parser = Fixtures.file("X221-HP835/1-good.txt")
      parser.should be_deterministic
      parser.should be_last

      parser.segment.tap do |iea|
        iea.node.position.line.should   == 40
        iea.node.position.column.should == 1
      end

      parser.should have_sequence(%w(ISA GS ST BPR TRN DTM N1 N3 N4 REF REF
        N1 REF LX TS3 TS2 CLP CAS NM1 MIA DTM DTM AMT QTY LX TS3 CLP CAS
        NM1 MOA DTM AMT PLB SE GE IEA))

      parser.should have_separators(:element => "+", :component => ">",
                                    :repetition => "~", :segment => "\r")

      parser.parent.tap do |isa|
        isa.should have_distance(35).to(parser)

        # See matchers/navigation_matchers.rb
        #
        # Ss: list of segment matchers
        #  C: composite element
        #
        #  S: the segment might be reachable, and /is/ reachable
        #  R: the segment might be reachable, but didn't occur
        #  X: the segment would never be reachable
        #
        isa.should have_structure(
          Ss(X(:ST),
             R(:ISA), # No more ISAs
             S(:GS, "HP", nil, nil, "19991231", nil, 1) =>
               Ss(R(:GS), # No more GSs
                  S(:ST) =>
                    Ss(R(:ST), # No more STs
                       S(:BPR, nil, 150000) =>
                         Ss(S(:TRN),
                            S(:DTM),
                            S(:N1, "PR"),
                            S(:N1, "PE"),
                            S(:LX, "110212"),
                            S(:LX, "130212"),
                            S(:PLB),
                            S(:SE),
                            S(:GE),
                            S(:IEA)),
                       S(:TRN, "1", "12345") =>
                         Ss(X(:BPR)),

                       S(:DTM, "405", Date.civil(2002, 9, 13)) =>
                         Ss(X(:TRN)),

                       # 1000A PAYER IDENTIFICATION
                       S(:N1, "PR", "INSURANCE COMPANY OF TIMBUCKTU") =>
                         Ss(S(:N3, "1 MAIN STREET"),
                            S(:N4),
                            S(:REF, "2U", "999"),
                            S(:REF, "NF", "12345"),
                            S(:SE),
                            S(:GE),
                            S(:IEA)),

                       # 1000B PAYEE IDENTIFICATION
                       S(:N1, "PE", nil, "XX", "1232343560") =>
                         Ss(S(:REF, "TJ"),
                            S(:SE),
                            S(:GE),
                            S(:IEA)),

                       # 2000 HEADER NUMBER
                       S(:LX, "110212") =>
                         Ss(S(:LX, "130212"),
                            S(:TS3),
                            S(:TS2),
                            S(:CLP) =>
                              Ss(S(:CAS, "CO", 45, "73348.57"),
                                 S(:NM1, "QC", nil, "JONES"),
                                 S(:MIA, 0, nil, nil, "138018.4".to_d),
                                 S(:DTM, "232", "20020816"),
                                 S(:DTM, "233", "20020824"),
                                 S(:AMT, "AU", 150000),
                                 S(:QTY, "CA", 8))),

                       # 2000 HEADER NUMBER
                       S(:LX, "130212") =>
                         Ss(R(:LX, "110212"),
                            S(:TS3, "6543210909", "13", "1996/12/31", 1, 15000),
                            S(:CLP, "777777") =>
                              Ss(S(:CAS, "CO", "45", "3019.67"),
                                 S(:NM1, "QC"),
                                 S(:MOA, nil, nil, "MA02"),
                                 S(:DTM, "232", "2002-05-12"),
                                 S(:AMT, "AU", 17000))),

                       S(:PLB, "6543210903") =>
                         Ss(S(:SE, 32, 1234),
                            S(:GE, 1, 1),
                            S(:IEA, 1, 905)),
                       S(:PLB, nil, "20021231") =>
                         Ss(S(:SE, "32", "1234"),
                            S(:GE, "1", "1"),
                            S(:IEA, "1", "905")),
                       S(:PLB, nil, nil, C("CV", "CP")) => Ss(),
                       S(:PLB, nil, nil, nil, "-1.27")  => Ss(),

                       S(:SE) => Ss(S(:GE),
                                    S(:IEA))),
                  S(:GE)  => Ss(S(:IEA)),
                  S(:IEA) => Ss())))
      end
    end

    context "issues with Table 3 (Summary)" do
      it "handles missing PLB" do
        parser = Fixtures.file("X221-HP835/2-good.txt")
        parser.should be_deterministic

        parser.parent.tap do |isa|
          isa.should have_structure(
            Ss(X(:SE),
               X(:PLB),
               S(:GS, "HP", nil, nil, "19991231", nil, 1) =>
                 Ss(X(:SE),
                    X(:PLB),
                    S(:ST) =>
                      Ss(R(:PLB),
                         S(:LX) =>
                           Ss(S(:SE),
                              R(:PLB)),
                         S(:SE) =>
                           Ss(X(:PLB),
                              X(:SE))))))
        end
      end

      it "handles single PLB" do
        parser = Fixtures.file("X221-HP835/1-good.txt")
        parser.should be_deterministic

        parser.parent.tap do |isa|
          isa.should have_structure(
            Ss(X(:SE),
               X(:PLB),
               S(:GS, "HP", nil, nil, "19991231", nil, 1) =>
                 Ss(X(:SE),
                    X(:PLB),
                    S(:ST) =>
                      Ss(S(:LX) =>
                           Ss(S(:SE),
                              S(:PLB)),
                         S(:SE) =>
                           Ss(X(:PLB),
                              X(:SE)),
                         S(:PLB) =>
                           Ss(R(:PLB), # only one PLB
                              S(:SE))))))
        end
      end

      it "handles multiple PLBs" do
        parser = Fixtures.file("X221-HP835/3a-good.txt")
        parser.should be_deterministic

        parser.parent.tap do |isa|
          isa.should have_structure(
            Ss(X(:SE),
               X(:PLB),
               S(:GS, "HP", nil, nil, "19991231", nil, 1) =>
                 Ss(X(:SE),
                    X(:PLB),
                    S(:ST) =>
                      Ss(S(:LX) =>
                           Ss(S(:SE),
                              S(:PLB),
                              S(:PLB, "9876543210"),
                              S(:PLB, "0123456789")),
                         S(:SE) =>
                           Ss(X(:PLB),
                              X(:SE)),
                         S(:PLB) =>
                           Ss(S(:PLB),
                              S(:PLB, "0123456789"),
                              R(:PLB, "9876543210"),
                              S(:SE)),
                         S(:PLB, "0123456789") =>
                           Ss(R(:PLB, "0123456789"),
                              R(:PLB, "9876543210"),
                              S(:SE)),
                         S(:PLB, "9876543210") =>
                           Ss(R(:PLB, "9876543210"),
                              S(:PLB, "0123456789"),
                              S(:SE))))))
        end
      end
    end

    context "table-level permutations" do
      # 837
      #   Table 2A
      #     2000A HL*..*..*20
      #   Table 2B
      #     2000B HL*..*..*22
      #   Table 2C
      #     2000C HL*..*..*23
      let(:dsl) do
        c = Stupidedi::Config.default
        b = Stupidedi::Builder::BuilderDsl.build(c, false)
        b.ISA("00", nil, "01", "SECRET", "ZZ", "SUBMITTER", "ZZ", "RECEIVER", Time.now.utc, Time.now.utc, nil, "00501", 123456789, "1", "T", nil) 
        b. GS("HP", "SENDER", "RECEIVER", Time.now.utc, Time.now.utc, 1, "X", "005010X222")
        b. ST("837", "0001", b.default)
          b.BHT("0019", "00", "46X2A6", Time.now.utc, Time.now.utc, "CH")
          b.NM1("41", "2", "TERRIBLE BILLING", nil, nil, nil, nil, "46", "X82BJJ")
            b.PER("IC", nil, "TE", "5551212")
          b.NM1("40", "2", "TERRIBLE INSURAN", nil, nil, nil, nil, "46", "3057XK")

        b # return BuilderDsl instance
      end

      specify "HL*..*..20, HL*..*..*22, HL*..*..*23" do
        ss = [["1", nil, "20", "1"],
              ["2", nil, "20", "1"],
              ["3", "1", "22", "1"],
              ["4", "2", "22", "1"],
              ["5", "3", "23", "0"],
              ["6", "4", "23", "0"]]

        ss.permutation do |p|
          b = dsl.dup
          p.each{|es| b.send(:HL, *es) }

          m = b.machine.first.flatmap{|x| x.sequence(:GS, :ST) }
          m.map{|x| x.count(:HL) }.should be_success(6)

          m.flatmap{|x| x.sequence(:HL) }.
            map{|x| x.count(:HL) }.should be_success(5)

          m.flatmap{|x| x.sequence(:HL, :HL) }.
            map{|x| x.count(:HL) }.should be_success(4)

          m.flatmap{|x| x.sequence(:HL, :HL, :HL) }.
            map{|x| x.count(:HL) }.should be_success(3)

          m.flatmap{|x| x.sequence(:HL, :HL, :HL, :HL) }.
            map{|x| x.count(:HL) }.should be_success(2)

          m.flatmap{|x| x.sequence(:HL, :HL, :HL, :HL, :HL) }.
            map{|x| x.count(:HL) }.should be_success(1)

          m.flatmap{|x| x.sequence(:HL, :HL, :HL, :HL, :HL, :HL) }.
            map{|x| x.count(:HL) }.should be_success(0)
        end if ss.respond_to?(:permutation)
      end
    end

    context "loop-level permutations" do
      # 837
      #   Table 1
      #     1000A NM1*41
      #     1000B NM1*40
      let(:dsl) do
        c = Stupidedi::Config.default
        b = Stupidedi::Builder::BuilderDsl.build(c, false)
        b.ISA("00", nil, "01", "SECRET", "ZZ", "SUBMITTER", "ZZ", "RECEIVER", Time.now.utc, Time.now.utc, nil, "00501", 123456789, "1", "T", nil) 
        b. GS("HP", "SENDER", "RECEIVER", Time.now.utc, Time.now.utc, 1, "X", "005010X222")
        b. ST("837", "0001", b.default)
          b.BHT("0019", "00", "46X2A6", Time.now.utc, Time.now.utc, "CH")

        b # return BuilderDsl instance
      end

      specify "NM1*41, NM1*40" do
        ss = [["41", "2", "TERRIBLE BILLING", nil, nil, nil, nil, "46", "X82BJJ"],
              ["40", "2", "TERRIBLE INSURAN", nil, nil, nil, nil, "46", "3057XK"]]

        ss.permutation do |p|
          b = dsl.dup
          p.each{|es| b.send(:NM1, *es) }

          m = b.machine.parent
          m.map{|x| x.count(:NM1) }.should be_success(2)

          m.flatmap{|x| x.sequence(:NM1) }.
            map{|x| x.count(:NM1) }.should be_success(1)

          m.flatmap{|x| x.sequence(:NM1, :NM1) }.
            map{|x| x.count(:NM1) }.should be_success(0)
        end if ss.respond_to?(:permutation)
      end
    end

    context "segment-level permutations" do
      # 835
      #   Table 1
      #     1000A N1*PR
      #       PER*CX
      #       PER*BL
      #       PER*IC

      let(:dsl) do
        c = Stupidedi::Config.default
        b = Stupidedi::Builder::BuilderDsl.build(c)
        b.ISA("00", nil, "01", "SECRET", "ZZ", "SUBMITTER", "ZZ", "RECEIVER", Time.now.utc, Time.now.utc, nil, "00501", 123456789, "1", "T", nil) 
        b. GS("HP", "SENDER", "RECEIVER", Time.now.utc, Time.now.utc, 1, "X", "005010X221")
        b. ST("835", "0001")
          b.BPR("C", 150000, "C", "ACH", "CTX", "01", "999999992", "DA", "123456", "1512345678", nil, "01", "999988880", "DA", "98765", "20020913")
          b.TRN("1", "12345", "1512345678")
          b.DTM("405", Time.now.utc)
          b. N1("PR", "INSURANCE COMPANY OF TIMBUCKTU")
            b. N3("1 MAIN STREET")
            b. N4("TIMBUCKTU", "AK", "99501")
            b.REF("2U", "999")
            b.REF("NF", "12345")

        b # return BuilderDsl instance
      end

      specify "PER*IC, PER*BL, PER*CX" do
        ss = [["IC", nil, "UR", "WEBSITE.COM"],
              ["BL", "COMPUTER PAT"],
              ["BL", "COMPUTER SAM"],
              ["CX", "BUSINESS KIM"]]

        ss.permutation do |p|
          b = dsl.dup
          p.each{|es| b.send(:PER, *es) }

          m = b.machine.parent
          m.map{|x| x.count(:PER) }.should be_success(4)

          m.flatmap{|x| x.sequence(:PER) }.
            map{|x| x.count(:PER) }.should be_success(3)

          m.flatmap{|x| x.sequence(:PER, :PER) }.
            map{|x| x.count(:PER) }.should be_success(2)

          m.flatmap{|x| x.sequence(:PER, :PER, :PER) }.
            map{|x| x.count(:PER) }.should be_success(1)

          m.flatmap{|x| x.sequence(:PER, :PER, :PER, :PER) }.
            map{|x| x.count(:PER) }.should be_success(0)
        end if ss.respond_to?(:permutation)
      end
    end

  end

end
